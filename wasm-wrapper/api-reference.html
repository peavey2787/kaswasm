<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Kaspa WASM Wrapper – API Reference</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      color-scheme: dark light;
      --bg: #050608;
      --bg-alt: #0b0e12;
      --border: #222a36;
      --text: #e5ecff;
      --muted: #94a3b8;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.08);
      --error: #f97373;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #0b1120 0, #020617 55%, #000 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(260px, 300px) minmax(0, 1fr);
      width: 100%;
      min-height: 100vh;
    }

    nav {
      border-right: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(15,23,42,0.96), rgba(15,23,42,0.98));
      padding: 1.25rem 1.5rem;
      position: sticky;
      top: 0;
      height: 100vh;
      overflow-y: auto;
    }

    main {
      padding: 1.75rem 2rem 2.5rem;
      overflow-y: auto;
    }

    h1 {
      font-size: 1.4rem;
      margin: 0 0 0.25rem;
      letter-spacing: 0.03em;
    }

    .subtitle {
      margin: 0 0 1.25rem;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.3);
      background: rgba(15,23,42,0.75);
    }

    .badge-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #a5f3fc, #0ea5e9);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.55), 0 0 20px rgba(34,211,238,0.8);
    }

    .toc-section {
      margin-top: 1.5rem;
    }

    .toc-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
      margin-bottom: 0.6rem;
    }

    .toc-list {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.86rem;
    }

    .toc-list li {
      margin-bottom: 0.25rem;
    }

    .toc-link {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      color: #e5ecff;
      text-decoration: none;
      padding: 0.15rem 0.25rem;
      border-radius: 0.35rem;
    }

    .toc-link span.kind {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    .toc-link:hover {
      background: rgba(15,23,42,0.9);
      color: #f9fafb;
    }

    .toc-link.active {
      background: var(--accent-soft);
      color: #f9fafb;
    }

    .toc-link .dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(148,163,184,0.7);
    }

    .toc-link.active .dot {
      background: #38bdf8;
    }

    .search {
      margin-top: 1.25rem;
      position: relative;
    }

    .search input {
      width: 100%;
      padding: 0.5rem 0.5rem 0.5rem 1.9rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.85);
      color: var(--text);
      font-size: 0.82rem;
    }

    .search input::placeholder {
      color: rgba(148,163,184,0.75);
    }

    .search-icon {
      position: absolute;
      left: 0.65rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.8rem;
      color: rgba(148,163,184,0.9);
    }

    .content-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
      margin-bottom: 0.5rem;
    }

    .content-header h2 {
      font-size: 1.1rem;
      margin: 0;
    }

    .content-meta {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .section-card {
      border-radius: 0.9rem;
      border: 1px solid rgba(148,163,184,0.2);
      background: radial-gradient(circle at top left, rgba(56,189,248,0.12), rgba(15,23,42,0.95));
      padding: 1rem 1.15rem 1.1rem;
      margin-bottom: 1rem;
    }

    .section-card + .section-card {
      background: linear-gradient(180deg, rgba(15,23,42,0.98), rgba(15,23,42,0.98));
    }

    .tagline {
      font-size: 0.86rem;
      color: var(--muted);
      margin-bottom: 0.3rem;
    }

    .signature {
      font-family: var(--mono);
      font-size: 0.82rem;
      padding: 0.4rem 0.5rem;
      border-radius: 0.5rem;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(30,64,175,0.7);
      overflow-x: auto;
      white-space: nowrap;
    }

    .member-list {
      margin-top: 0.55rem;
      border-left: 1px solid rgba(51,65,85,0.9);
      padding-left: 0.8rem;
    }

    .member {
      margin-bottom: 0.6rem;
    }

    .member-kind {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: rgba(148,163,184,0.85);
      margin-bottom: 0.1rem;
    }

    .member-signature {
      font-family: var(--mono);
      font-size: 0.8rem;
      color: #e2e8f0;
      padding: 0.2rem 0.4rem;
      border-radius: 0.35rem;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(30,64,175,0.7);
      display: inline-block;
      max-width: 100%;
      overflow-x: auto;
      white-space: nowrap;
    }

    .member-notes {
      font-size: 0.78rem;
      color: var(--muted);
      margin-top: 0.15rem;
    }

    code {
      font-family: var(--mono);
      font-size: 0.78rem;
      padding: 0.12rem 0.25rem;
      border-radius: 0.3rem;
      background: rgba(15,23,42,0.92);
      border: 1px solid rgba(30,64,175,0.7);
    }

    pre {
      font-family: var(--mono);
      font-size: 0.78rem;
      padding: 0.7rem 0.8rem;
      border-radius: 0.55rem;
      background: rgba(15,23,42,0.96);
      border: 1px solid rgba(30,64,175,0.6);
      overflow-x: auto;
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      font-size: 0.7rem;
      margin-top: 0.4rem;
    }

    .pill {
      padding: 0.16rem 0.45rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.92);
      color: rgba(226,232,240,0.96);
    }

    .pill.primary {
      border-color: rgba(56,189,248,0.6);
      background: rgba(8,47,73,0.9);
      color: #e0f2fe;
    }

    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      align-items: center;
      margin-top: 0.45rem;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .status-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 12px rgba(34,197,94,0.9);
    }

    .error-box {
      margin-top: 0.8rem;
      padding: 0.55rem 0.65rem;
      border-radius: 0.55rem;
      background: rgba(127,29,29,0.22);
      border: 1px solid rgba(248,113,113,0.7);
      color: #fee2e2;
      font-size: 0.78rem;
    }

    .hidden { display: none !important; }

    @media (max-width: 880px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
      nav {
        position: static;
        height: auto;
        border-right: none;
        border-bottom: 1px solid var(--border);
      }
    }
  </style>
</head>
<body>
  <div class="layout">
    <nav>
      <div style="display:flex;align-items:center;gap:0.55rem;margin-bottom:0.5rem;">
        <div class="badge-dot"></div>
        <div>
          <div style="font-size:0.8rem;letter-spacing:0.16em;text-transform:uppercase;color:var(--muted);">Kaspa WASM Wrapper</div>
          <h1>API Reference</h1>
        </div>
      </div>
      <p class="subtitle">Generated dynamically at runtime from the wrapper modules. Uses simple reflection over classes and functions; always reflects the current codebase.</p>

      <div class="badge" style="margin-bottom:0.6rem;">
        <span class="badge-dot"></span>
        <span>Live module inspection</span>
      </div>

      <div class="search">
        <span class="search-icon">⌕</span>
        <input id="searchBox" type="search" placeholder="Filter by symbol or file…" autocomplete="off" />
      </div>

      <div class="toc-section">
        <div class="toc-title">Modules</div>
        <ul id="toc" class="toc-list"></ul>
      </div>
    </nav>

    <main>
      <header style="margin-bottom:1.1rem;">
        <div class="content-header">
          <h2 id="page-title">Wrapper API documentation</h2>
          <div class="content-meta" id="summary-meta">Loading module metadata…</div>
        </div>
        <p class="tagline">Each section below is generated from the actual JavaScript source using runtime reflection. Parameter lists are parsed from function signatures where possible.</p>
        <div class="pill-row">
          <span class="pill primary">Source of truth: JS modules</span>
          <span class="pill">Classes, methods, statics & utilities</span>
          <span class="pill">Non-invasive, no build step</span>
        </div>
      </header>

      <section id="content"></section>

      <section style="margin-top:1.5rem;font-size:0.78rem;color:var(--muted);">
        <p>Limitations: Parameter names and some details are derived from function source strings; heavily minified builds may reduce fidelity. For authoritative type information, consult the Kaspa WASM SDK docs.</p>
      </section>
    </main>
  </div>

  <script type="module">
    // Adjust these paths if you move this file.
    const MODULE_CONFIG = [
      { id: 'KaspaClient', file: './KaspaClient.js', display: 'KaspaClient.js', kind: 'module' },
      { id: 'Wallet', file: './Wallet.js', display: 'Wallet.js', kind: 'module' },
      { id: 'Events', file: './Events.js', display: 'Events.js', kind: 'module' },
      { id: 'BlockScanner', file: './BlockScanner.js', display: 'BlockScanner.js', kind: 'module' },
      { id: 'UtxoContext', file: './UtxoContext.js', display: 'UtxoContext.js', kind: 'module' },
      { id: 'Utilities', file: './Utilities.js', display: 'Utilities.js', kind: 'module' },
      { id: 'Constants', file: './Constants.js', display: 'Constants.js', kind: 'module' },
      { id: 'Errors', file: './Errors.js', display: 'Errors.js', kind: 'module' }
    ];

    function parseParamsFromSource(fn) {
      if (typeof fn !== 'function') return [];
      const src = Function.prototype.toString.call(fn).replace(/\n/g, ' ');
      const match = src.match(/^[^(]*\(([^)]*)\)/);
      if (!match) return [];
      const raw = match[1].trim();
      if (!raw) return [];
      return raw.split(',').map(p => p.trim()).filter(Boolean);
    }

    function buildSignature(name, kind, params, asyncLike = false) {
      const paramStr = params.join(', ');
      if (kind === 'constructor') {
        return `constructor(${paramStr})`;
      }
      const prefix = asyncLike ? 'async ' : '';
      return `${prefix}${name}(${paramStr})`;
    }

    function isClassLike(fn) {
      if (typeof fn !== 'function') return false;
      const src = Function.prototype.toString.call(fn).trim();
      return src.startsWith('class ');
    }

    function normalizeMemberName(name) {
      if (name === 'constructor') return 'constructor';
      return name;
    }

    function collectClassMembers(ctor) {
      const instanceMethods = [];
      const staticMethods = [];

      if (!ctor || typeof ctor !== 'function') {
        return { instanceMethods, staticMethods };
      }

      const proto = ctor.prototype || {};
      for (const name of Object.getOwnPropertyNames(proto)) {
        if (name === 'constructor') continue;
        const desc = Object.getOwnPropertyDescriptor(proto, name);
        if (!desc) continue;
        if (typeof desc.value === 'function') {
          const params = parseParamsFromSource(desc.value);
          const asyncLike = /^\s*async\b/.test(Function.prototype.toString.call(desc.value));
          instanceMethods.push({
            name: normalizeMemberName(name),
            kind: 'method',
            signature: buildSignature(name, 'method', params, asyncLike),
            params
          });
        } else {
          if (typeof desc.get === 'function') {
            instanceMethods.push({
              name: name,
              kind: 'getter',
              signature: `${name}: <get>`,
              params: []
            });
          }
          if (typeof desc.set === 'function') {
            const params = parseParamsFromSource(desc.set);
            instanceMethods.push({
              name: name,
              kind: 'setter',
              signature: `${name}: <set>(${params.join(', ')})`,
              params
            });
          }
        }
      }

      const staticNames = Object.getOwnPropertyNames(ctor).filter(n => !['length','name','prototype'].includes(n));
      for (const name of staticNames) {
        const desc = Object.getOwnPropertyDescriptor(ctor, name);
        if (!desc) continue;
        if (typeof desc.value === 'function') {
          const params = parseParamsFromSource(desc.value);
          const asyncLike = /^\s*async\b/.test(Function.prototype.toString.call(desc.value));
          staticMethods.push({
            name,
            kind: 'static',
            signature: buildSignature(name, 'method', params, asyncLike),
            params
          });
        }
      }

      return { instanceMethods, staticMethods };
    }

    function collectPlainExports(mod, moduleLabel) {
      const items = [];
      for (const key of Object.keys(mod)) {
        const value = mod[key];
        if (typeof value === 'function') {
          const params = parseParamsFromSource(value);
          const asyncLike = /^\s*async\b/.test(Function.prototype.toString.call(value));
          items.push({
            name: key,
            kind: 'function',
            signature: buildSignature(key, 'function', params, asyncLike),
            params
          });
        } else if (typeof value === 'object' && value !== null) {
          items.push({
            name: key,
            kind: 'value',
            signature: `${key}: ${Array.isArray(value) ? 'array' : 'object'}`,
            params: []
          });
        } else {
          items.push({
            name: key,
            kind: 'value',
            signature: `${key}: ${typeof value}`,
            params: []
          });
        }
      }
      return items;
    }

    function categorizeModule(moduleExports, config) {
      const sections = [];
      const { id, display } = config;

      if (moduleExports.default && (isClassLike(moduleExports.default) || typeof moduleExports.default === 'function')) {
        const ctor = moduleExports.default;
        const ctorParams = parseParamsFromSource(ctor);
        const ctorSig = buildSignature('constructor', 'constructor', ctorParams, false);
        const { instanceMethods, staticMethods } = collectClassMembers(ctor);

        sections.push({
          type: 'class',
          name: ctor.name || id,
          moduleDisplay: display,
          constructorSignature: ctorSig,
          constructorParams: ctorParams,
          instanceMethods: instanceMethods.sort((a,b) => a.name.localeCompare(b.name)),
          staticMethods: staticMethods.sort((a,b) => a.name.localeCompare(b.name)),
          rawCtor: ctor
        });
      }

      const remainingKeys = Object.keys(moduleExports).filter(k => k !== 'default');
      if (remainingKeys.length) {
        const plain = {};
        for (const k of remainingKeys) plain[k] = moduleExports[k];
        const exportsList = collectPlainExports(plain, display).sort((a,b) => a.name.localeCompare(b.name));
        if (exportsList.length) {
          sections.push({
            type: 'exports',
            name: display,
            moduleDisplay: display,
            exports: exportsList
          });
        }
      }

      return sections;
    }

    function createMemberRow(member) {
      const div = document.createElement('div');
      div.className = 'member';

      const kind = document.createElement('div');
      kind.className = 'member-kind';
      kind.textContent = member.kind.toUpperCase();

      const sig = document.createElement('div');
      sig.className = 'member-signature';
      sig.textContent = member.signature;

      div.appendChild(kind);
      div.appendChild(sig);

      return div;
    }

    function renderModuleSections(container, moduleId, moduleSections) {
      container.innerHTML = '';

      for (const sec of moduleSections) {
        const card = document.createElement('article');
        card.className = 'section-card';
        card.id = `module-${moduleId}-${sec.name}`;

        const header = document.createElement('div');
        header.className = 'content-header';

        const h2 = document.createElement('h2');
        h2.textContent = sec.type === 'class' ? sec.name : sec.name;
        header.appendChild(h2);

        const meta = document.createElement('div');
        meta.className = 'content-meta';
        meta.textContent = sec.type === 'class'
          ? `Class from ${sec.moduleDisplay}`
          : `Exports from ${sec.moduleDisplay}`;
        header.appendChild(meta);

        card.appendChild(header);

        const tagline = document.createElement('p');
        tagline.className = 'tagline';
        if (sec.type === 'class') {
          tagline.textContent = 'Instance-based wrapper with async methods and event helpers.';
        } else {
          tagline.textContent = 'Additional exported helpers, constants and utility functions.';
        }
        card.appendChild(tagline);

        if (sec.type === 'class') {
          const ctor = document.createElement('div');
          ctor.className = 'signature';
          ctor.textContent = `new ${sec.name}(${sec.constructorParams.join(', ')})`;
          card.appendChild(ctor);

          const memberList = document.createElement('div');
          memberList.className = 'member-list';

          if (sec.instanceMethods.length) {
            const instLabel = document.createElement('div');
            instLabel.className = 'member-kind';
            instLabel.textContent = 'INSTANCE METHODS';
            memberList.appendChild(instLabel);
            for (const m of sec.instanceMethods) {
              memberList.appendChild(createMemberRow(m));
            }
          }

          if (sec.staticMethods.length) {
            const statLabel = document.createElement('div');
            statLabel.className = 'member-kind';
            statLabel.textContent = 'STATIC MEMBERS';
            statLabel.style.marginTop = '0.35rem';
            memberList.appendChild(statLabel);
            for (const m of sec.staticMethods) {
              memberList.appendChild(createMemberRow(m));
            }
          }

          card.appendChild(memberList);
        } else if (sec.type === 'exports') {
          const memberList = document.createElement('div');
          memberList.className = 'member-list';
          for (const exp of sec.exports) {
            memberList.appendChild(createMemberRow(exp));
          }
          card.appendChild(memberList);
        }

        container.appendChild(card);
      }
    }

    function buildToc(allModules) {
      const toc = document.getElementById('toc');
      toc.innerHTML = '';

      for (const mod of allModules) {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = '#';
        a.className = 'toc-link';
        a.dataset.moduleId = mod.id;

        const dot = document.createElement('span');
        dot.className = 'dot';
        a.appendChild(dot);

        const label = document.createElement('span');
        label.textContent = mod.display;
        a.appendChild(label);

        const kind = document.createElement('span');
        kind.className = 'kind';
        kind.textContent = 'MODULE';
        a.appendChild(kind);

        li.appendChild(a);
        toc.appendChild(li);
      }
    }

    function applySearchFilter(query) {
      const q = query.trim().toLowerCase();
      const cards = document.querySelectorAll('.section-card');
      if (!q) {
        cards.forEach(c => c.classList.remove('hidden'));
        return;
      }
      cards.forEach(card => {
        const text = card.textContent.toLowerCase();
        if (text.includes(q)) card.classList.remove('hidden');
        else card.classList.add('hidden');
      });
    }

    async function main() {
      const content = document.getElementById('content');
      const meta = document.getElementById('summary-meta');
      const search = document.getElementById('searchBox');
      const titleEl = document.getElementById('page-title');

      try {
        const loaded = [];
        for (const cfg of MODULE_CONFIG) {
          try {
            const mod = await import(cfg.file);
            const sections = categorizeModule(mod, cfg);
            loaded.push({ ...cfg, sections });
          } catch (err) {
            console.error('Failed to import module', cfg.file, err);
            const errCard = document.createElement('article');
            errCard.className = 'section-card';
            errCard.id = `module-${cfg.id}`;

            const header = document.createElement('div');
            header.className = 'content-header';
            const h2 = document.createElement('h2');
            h2.textContent = cfg.display;
            header.appendChild(h2);
            const m = document.createElement('div');
            m.className = 'content-meta';
            m.textContent = 'Error loading module';
            header.appendChild(m);
            errCard.appendChild(header);

            const box = document.createElement('div');
            box.className = 'error-box';
            box.textContent = String(err && err.message || err);
            errCard.appendChild(box);

            content.appendChild(errCard);
          }
        }

        buildToc(loaded);

        function markActiveModule(moduleId) {
          const links = document.querySelectorAll('.toc-link');
          links.forEach(link => {
            if (link.dataset.moduleId === moduleId) link.classList.add('active');
            else link.classList.remove('active');
          });
        }

        function showModule(mod) {
          if (!mod) return;
          renderModuleSections(content, mod.id, mod.sections);
          const symbolCount = Array.from(content.querySelectorAll('.member-signature')).length;
          titleEl.textContent = `${mod.display} API`;
          meta.textContent = `${mod.display} · ${symbolCount} symbols · ${loaded.length} modules indexed`;
          markActiveModule(mod.id);
          applySearchFilter(search.value || '');
        }

        // Default to first successfully loaded module
        if (loaded.length > 0) {
          showModule(loaded[0]);
        } else {
          meta.textContent = 'No modules loaded.';
        }

        const toc = document.getElementById('toc');
        toc.addEventListener('click', (event) => {
          const target = event.target.closest('.toc-link');
          if (!target) return;
          event.preventDefault();
          const id = target.dataset.moduleId;
          const mod = loaded.find(m => m.id === id);
          showModule(mod);
        });

        search.addEventListener('input', e => applySearchFilter(e.target.value));
      } catch (err) {
        console.error('API doc generation failed', err);
        meta.textContent = 'Failed to generate documentation. See console for details.';
      }
    }

    main();
  </script>
</body>
</html>
